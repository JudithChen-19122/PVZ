# **南京大学本科生实验报告**

课程名称：高级程序设计            任课教师：程家俊/左志强          助教：丁鹏

| 学院  | 计算机科学与技术系 | 专业（方向）  | 计算机科学与技术    |
| ----- | ------------------ | ------------- | ------------------- |
| 学号  | 191220013          | 姓名          | 陈奕诺              |
| Email | 1053650507@qq.com  | 开始/完成日期 | 2021.3.23/2021.4.13 |

## **1.**  **实验名称**

高程课设第一阶段：基于控制台的植物大战僵尸

## 2. 主要内容/要求：

基于控制台实现一个简单的植物大战僵尸程序。主要实现以下基础设计：

1、庭院布局3行7列

2、每隔6秒生成25点自然阳光

3、实现普通僵尸

4、实现普通僵尸的三种属性： 生命值、攻击力、速度

5、假定每个地块中只能有⼀只僵僵尸（由于后续需要实现多僵尸，这里没有做相应的保护机制）

6、实现豌豆射手

7、实现豌豆射手的属性：生命值、攻击力、攻击速度

8、实现豌豆射手发射子弹的功能，实现子弹的基本属性：攻击力、速度、攻击方式

9、实现了简单的商店功能：植物的购买和种植、地块的选择

10、实现了一个简单的随时间递减的记分牌

最终实现的效果如下图所示：

![](E:\QQ下载文件\picture\g2.png)

## 3.主要设计思路

针对植物大战僵尸的游戏特点，考虑到后续的内容扩充的需要，目前主要有两种设计思路。一种是将所有的攻击操作作为一个攻击类来实现，另一种则是通过地块攻击法来实现，结合游戏本身的设计特点，为了简化后续编程操作，我最终选择了地块攻击法来实现。

基于这一设计思路，我们可以发现，地块是所有操作的核心，他起到植物、僵尸、子弹、商店等对象间的信息传输功能（比如：僵尸攻击信息先从僵尸传给地块，再由地块传递给相应的植物），从而将所有的对象联系起来，组成一个关联性较强的体系。

## 4.主要类/模块设计

这次实现中，我们主要设计了如下模块/类对象：

1、Game: 游戏顶层模块，提供用户接口，统筹所有类操作，控制程序的运行；

2、Map: 地图类，负责庭院的基础布局设计，统筹所有的地块，建立地块间的联系，保障攻击/移动;

3、Grid: 地块类，信息传递和储存操作由它来完成，是本此游戏实现的核心；

4、Zombie: 普通僵尸类， 设置僵尸的基本属性，存储每只僵尸的状态, 提供移动/攻击等功能函数；

5、Plant: 植物基础类，提供植物共有属性，为后续不同植物设计提供良好的继承基础类；

6、Peashooter: 豌豆射手类，设置豌豆射手的属性，存储每个豌豆射手的状态, 提供攻击等功能函数；

7、Bullet: 子弹类，设置子弹的基本属性，提供移动/攻击等功能函数；

8、Store: 商店类， 打印商品信息，存储阳光信息，提供购买、种植等功能函数；

9、Good: 商品类,   设置商品基本属性，通过商品状态存储；

## 5.类之间的基本关系：

简单的对Game类的关键成员函数和作用进行图解：

![](E:\QQ下载文件\picture\g3.png)

不难发现我们所有的操作，实际功能的调用都是由Game来是实现的，Game包含了整体的游戏逻辑。

下面我们来简单的用关系图描绘一下类间的一些主要的关系：

![](E:\QQ下载文件\picture\g4.png)

由上图可知，Game和Map是Store、Plant、Bullet、Zombie实现信息交互的桥梁，他们四类之间不能直接交互，而要通过Game和Map实现间接的信息同步，从而实现整体的同步；

## 6.功能实现

由于操作内容相对繁复，我们这里只举例其中一个相对比较典型的例子来说明：

我们举例植物发射子弹攻击僵尸的过程：

首先是Game类调用makeplant函数，遍历所有的植物对象，并调用所有植物对象的功能函数，每一个植物对象Peashooter 类调用 `void shoot(Game *game, Map* map)；`  函数：

```
void Peashooter::shoot(Game* game, Map* map) {

	bool temp=false; 
	for (int j = 0; j < 7; j++) {
		if (map->grid[j][y].haszombie()) {
			temp = true;  //该行上有僵尸
			break;
		}
	}

	if (!temp) return;
	counter += 1;
	if (counter >= speed) {
		game->addbullet(x, y);
		counter = 0;
	}
}
```

首先他获取Map类的信息来判断植物所在行是否有僵尸，若没有，不进行操作，若有，则向Game类传递信息（调用函数），让Game类在其所在位置生成一个Bullet对象，并加入到Game类的Vector中：

```
void Game::addbullet(int tx, int ty) {
	if (tx < 0 || tx >= COL || ty < 0 || ty >= ROW) return;
	Bullet* b = new Bullet;
	b->locate(tx, ty);
	map->grid[tx][ty].addBullet(b);
	bullets.push_back(b);
}
```

Game类的addbullet函数同时又向Map类传递信息（调用函数），让Map类在其所在地块加入我们生成的bullet对象，并实现信息的输出：

```
void Grid::addBullet(Bullet* b) {
	bullets.push_back(b);
	refresh = true;
}
```

现在为止，我们已经完成了Game,Map,Bullet,Peashooter在植物发射子弹这一操作上的统一。接下来植物的攻击操作转移到了Bullet类上，我们看到Game类的run循环中有Bullet有固定的操作，遍历Bullet对象，调用Bullet对象的功能函数:

```
void Game::makebullet() {
	for (int i = 0; i < bullets.size(); i++) {
		bullets[i]->move(map,this);
	}
}
```

每一个Bullet对象调用`move(Map* map, Game* game)` 函数：

```
void Bullet::move(Map* map, Game* game) {
	if (judgeifattack(map)) {
		map->grid[x][y].attackZombie(ATK, game);
		map->grid[x][y].killBullet(this, game);
		return;
	}
	counter += 1;
	if (counter >= speed) {
		if (x >= 6) {
			map->grid[x][y].killBullet(this, game);
		}
		else {
			map->grid[x][y].delBullet(this);
			x++;
			map->grid[x][y].addBullet(this);
			counter = 0;
		}
	}
}
```

首先他获取Map类的信息来判断子弹所在位置是否有僵尸，若没有，则调用Map类的相关操作，消除本Grid中的子弹，添加下一个Grid中的子弹，从而实现移动；若有，则攻击僵尸，将信息传递给Map类，Map类再调用函数，将信息传递给Zombie对象，Zombie对象再调用函数对自己进行操作，同时Map类调用Grid的子弹删除函数`killBullet(this, game);`：

```
void Grid::killBullet(Bullet* b, Game* game) {
	delBullet(b);
	for (int i = 0; i < game->bullets.size(); i++) {
		if (b == game->bullets[i])
		{
			game->bullets[i] = game->bullets[game->bullets.size() - 1];
			game->bullets.pop_back();
			break;
		}
	}
	delete b;
	b = NULL;
	refresh = true;

}
```

将Grid中的子弹删除，同时传递信息给Game对象，Game对象删除储存在Vector中的bullet。

现在子弹的攻击信息已经传递给了地块，接下来我们看看地块的具体攻击操作：

```
void Grid::attackZombie(int ATK, Game* game) {
	if (zombie != NULL) {
		zombie->HP -= ATK;
		if (zombie->HP <= 0) {
			killZombie(game);
		}
		refresh = true;
	}
}
```

具体就是将攻击操作传递给僵尸类，若僵尸被杀死，则删除地块和Game中对应的僵尸：

```
void Grid::killZombie(Game* game) {
	for(int i=0;i<game->zombies.size();i++)
		if (zombie == game->zombies[i])
		{
			game->zombies[i] = game->zombies[game->zombies.size() - 1];
			game->zombies.pop_back();
			break;
		}
	delete zombie;
	zombie = NULL;
	refresh = true;
}
```

自此，我们完成了Game, Plant, Bullet, Zombie, Map, Grid的与植物攻击僵尸相关的基础同步操作，其他的诸如僵尸攻击植物的操作，其基本信息传递模式与之类似，这里不再过多赘述，现在我们通过一个简单的关系图来还原一下上述操作，使其更加明了：

![](E:\QQ下载文件\picture\g6.png)





## 7.程序的功能亮点与运行操作方法

程序功能以基础功能为主，操作方法为依赖键盘监听机制的键盘操作，依据左下角的文字提示进行具体的操作。

人为操作主要是购买和种植植物，包括选择地块（按B进入购买模式后按C进行选择，选择地块坐标在右上角，且地块中有“RRRR”标于上方，选好后，按ESC退出，回到购买界面，按“0”种植豌豆射手到相应位置，成功则扣除相应阳光，商品进入冷却模式，无法购买，按ESC退出后游戏运行，冷却时间开始变化）；注意为了简化编程，这里我们暂时用“OOO”代替子弹。

## 8.遇到的问题与解决方案

一开始难以入手，没有恰切的设计思路，通过与同学交流和上网查询相关的资料，了解了攻击类和地块攻击法，为后续的设计指明了方向。

控制台输出不熟悉，对游戏界面的设计产生了一定的干扰，上网查到了gotoxy函数这一移动光标位置输出的办法，另开了一个简单的小程序进行编程来确定各个输出合适的位置和计算的方式。

由于类对象众多且调用关系复杂，出现了由于各类相互包含而在编译时出现未定义的类等错误，后来通过使用指针作为参数而非类对象本身作为参数的办法解决了冲突。

运行过程中出现内存错误，难以确认错误的位置，通过跟踪函数的实现，一步步打断点，添加中间变量的方式来检查，一点点排除错误，最终找出错误的位置。

对于类的继承不熟悉，尝试的做了“向日葵”的设计，但是最终没能实现其功能，上网查阅后了解到了虚拟函数等知识，但由于时间关系，尚未实现其设计，期待在后续的学习过程中能够得到解决。

## 9.后来发现的问题（待更改）

1.子弹有时出现“隔山打牛”（子弹错过僵尸）现象：

在Game的run_normal()中，我们是先对僵尸做了移动/攻击操作，再对子弹操作的，这可能导致在子弹判断格子中是否有僵尸时，僵尸已经移动到前面的格子里了，导致攻击的僵尸是后面的僵尸，而非前面的僵尸。

首先我们可以将子弹操作提前到对僵尸操作之前。发现还是存在同样的问题。进一步观察发现存在这样的情况，子弹本格子没有僵尸，于是移动而不攻击，下一步僵尸移动到之前的格，而子弹已经移动到下一格，于是没有攻击而是移动。于是我们对子弹的攻击和移动判断加以改进，在移动后立即对于本格僵尸进行攻击判断。

已经实现了更改：

![](E:\QQ下载文件\picture\g7.png)

2.僵尸只吃前一格的植物，但是增加僵尸时没有排除和植物出现在同一格的情况（留待第二阶段更改）

3.由于考虑到后面的设计，没有做僵尸不能在同一格的判断

4.进入商店模式时游戏停止运行（能否改为多线程？）

5.前期为了简化书写，运用了大量的友元操作，可能导致程序数据不够安全，后续要尽可能进行封装

6.没有恰当运用虚函数，所有的植物默认为peashooter给后续更改带来了一定的麻烦

7.函数的封装不是很合适，Game中的很多函数可以由PUBLIC转为PRIVATE

8.模块的关系不是很明了，尤其是Game和Map的调用选择没有统一，可能给后续的设计带来麻烦

9.大量冗余的刷新操作

10.一些信息打印的位置错误

11.选择框美化（已修改，代码在注释部分，之前可能存在未知的编译错误）

12. 刷新率为每秒一帧，导致键盘操作延时，后续应该尽量向60帧每秒的实际帧数靠近。